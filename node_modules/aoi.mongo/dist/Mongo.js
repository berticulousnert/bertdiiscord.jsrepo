"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mongo = void 0;
const Cursor_1 = require("./Cursor");
const Generator_1 = require("./Generator");
const query_1 = require("./query");
/** The mongo instance constructor */
class Mongo {
    /**
     * @param options The options for the mongo instance
     */
    constructor(options) {
        if (typeof options !== "object" || options === null)
            throw new TypeError("options must be a non-null object");
        if (typeof options.client !== "object" || options === null)
            throw new TypeError("client option must be a non-null object");
        if (typeof options.dbName !== "string")
            throw new TypeError("dbName option must be a valid string");
        if (typeof options.collectionName !== "string")
            throw new TypeError("collectionName option must be a valid string");
        this.client = options.client;
        this.db = this.client.db(options.dbName, options.dbOptions);
        this.collection = this.db.collection(options.collectionName, options.collectionOptions);
        void this.index({ key: 1 }, { unique: true });
    }
    /**
     * Set a data into the collection
     * @param key The data key
     * @param value The data value
     */
    async set(key, value) {
        const refs = [];
        const data = (0, Generator_1.generate)(value, refs);
        const res = await this.collection.updateOne({ key }, {
            $setOnInsert: { key },
            $set: { data, refs }
        }, { upsert: true });
        return res;
    }
    /**
     * Get a document from the collection
     * @param key The document key
     */
    async get(key) {
        return this.query(this.filter()
            .key
            .equal(key)).findOne();
    }
    /**
     * Delete a document from the collection
     * @param key The document key
     */
    async delete(key) {
        return this.query(this.filter()
            .key
            .equal(key)).deleteOne();
    }
    /**
     * Find and match all document key with the matcher in the collection
     * @param matcher The matcher in regex
     */
    async match(matcher) {
        return this.query(this.filter()
            .key
            .match(matcher)).findMulti();
    }
    /**
     * Get all document in the collection
     */
    async all() {
        const cursor = await this.collection.find({});
        return new Cursor_1.Cursor(cursor);
    }
    /** Create an index in the ocllection */
    async index(indexSpec, options) {
        const spec = {};
        if (typeof indexSpec.key !== "undefined")
            spec.key = indexSpec.key;
        if (typeof indexSpec.data !== "undefined") {
            if (typeof indexSpec.data === "object") {
                const keys = Object.keys(indexSpec.data);
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    if (!key.startsWith("$") && !key.includes(".") && !key.includes("\x00")) {
                        spec[`refs.0.${key}`] = indexSpec.data[key];
                    }
                }
            }
            else
                spec.data = indexSpec.data;
        }
        if (options)
            await this.collection.createIndex(spec, options);
        else
            await this.collection.createIndex(spec);
    }
    /** Create a query object */
    query(match) {
        return new query_1.Query(this, match);
    }
    /** Shortcut for creating filter */
    filter() {
        return new query_1.Filter();
    }
}
exports.Mongo = Mongo;
