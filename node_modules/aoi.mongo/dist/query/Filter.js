"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArbitraryFilter = exports.Filter = void 0;
const Match_1 = require("./Match");
const Length_1 = require("./Length");
const Bool_1 = require("./Bool");
const Date_1 = require("./Date");
const BigInt_1 = require("./BigInt");
const Number_1 = require("./Number");
const String_1 = require("./String");
const Array_1 = require("./Array");
const RegExp_1 = require("./RegExp");
const IncString_1 = require("../IncString");
/** Filter for querying */
class Filter {
    /** The key filter */
    get key() {
        const expr = {};
        return new String_1.StrFilter("$key", { $expr: expr }, expr);
    }
    /** The data filter */
    get data() {
        const expr = {};
        return new ArbitraryFilter(new IncString_1.IncrementalString(), "$data", { $expr: expr }, expr);
    }
}
exports.Filter = Filter;
/** Arbitrary filter for data */
class ArbitraryFilter {
    constructor(str, path, filter, expr) {
        this.str = str;
        this.path = path;
        this.filter = filter;
        this.expr = expr;
    }
    /** Filter if the data is nullish */
    get nullish() {
        const match = new Match_1.Match(this.filter);
        this.expr.$or = [
            {
                $eq: [{
                        $type: this.path
                    }, "missing"]
            },
            {
                $eq: [this.path, null]
            },
            {
                $eq: [`${this.path}.type`, 0 /* Null */]
            }
        ];
        return match;
    }
    bool() {
        const expr = {};
        const filter = new Bool_1.BoolFilter(`${this.path}.bool`, this.filter, expr);
        this.resolveValue(expr, 1 /* Bool */);
        return filter;
    }
    number() {
        const expr = {};
        const filter = new Number_1.NumFilter(`${this.path}.num`, this.filter, expr);
        this.resolveValue(expr, 2 /* Number */);
        return filter;
    }
    bigint() {
        const expr = {};
        const filter = new BigInt_1.BigFilter(`${this.path}.big`, this.filter, expr);
        this.resolveValue(expr, 3 /* BigInt */);
        return filter;
    }
    string() {
        const expr = {};
        const filter = new String_1.StrFilter(`${this.path}.str`, this.filter, expr);
        this.resolveValue(expr, 4 /* String */);
        return filter;
    }
    date() {
        const expr = {};
        const filter = new Date_1.DateFilter(this.str, `${this.path}.date`, this.filter, expr);
        this.resolveValue(expr, 5 /* Date */);
        return filter;
    }
    regexp() {
        const expr = {};
        const filter = new RegExp_1.RegexFilter(`${this.path}.regex`, this.filter, expr);
        this.resolveValue(expr, 6 /* RegExp */);
        return filter;
    }
    byteLength() {
        const expr = {};
        const path = this.resolveReference(expr, 7 /* Bytes */);
        return new Length_1.Length("$binarySize", `${path}.buf`, this.filter, expr);
    }
    array() {
        const expr = {};
        const path = this.resolveReference(expr, 8 /* Array */);
        return new Array_1.ArrayFilter(this.str, `${path}.arr`, this.filter, expr);
    }
    set() {
        const expr = {};
        const path = this.resolveReference(expr, 8 /* Array */);
        return new Array_1.ArrayFilter(this.str, `${path}.set`, this.filter, expr);
    }
    mapGet(key) {
        if (key.startsWith("$") || key.includes(".") || key.includes("\x00"))
            throw new Error(`key can't start with $, include dot (.), or include null character`);
        const expr = {};
        const path = this.resolveReference(expr, 10 /* Map */);
        const propExpr = {};
        const variable = this.str.str;
        this.str.increment();
        expr.$let = {
            vars: {
                [variable]: `${path}.map.${key}`
            },
            in: propExpr
        };
        return new ArbitraryFilter(this.str, `$$${variable}`, this.filter, propExpr);
    }
    objGet(key) {
        if (key.startsWith("$") || key.includes(".") || key.includes("\x00"))
            throw new Error(`key can't start with $, include dot (.), or include null character`);
        const expr = {};
        const path = this.resolveReference(expr, 11 /* Object */);
        const propExpr = {};
        const variable = this.str.str;
        this.str.increment();
        expr.$let = {
            vars: {
                [variable]: `${path}.obj.${key}`
            },
            in: propExpr
        };
        return new ArbitraryFilter(this.str, `$$${variable}`, this.filter, propExpr);
    }
    /** Filter if data type is equal */
    typeOf(type, resolveRef = false) {
        const match = new Match_1.Match(this.filter);
        if (resolveRef) {
            const variable = this.str.str;
            this.expr.$cond = [
                {
                    $or: [
                        {
                            $eq: [`${this.path}.type`, { $literal: type }]
                        },
                        {
                            $eq: [`${this.path}.type`, 12 /* Reference */]
                        }
                    ]
                },
                {
                    $let: {
                        vars: {
                            [variable]: {
                                $cond: [
                                    {
                                        $eq: [`${this.path}.type`, 12 /* Reference */]
                                    },
                                    {
                                        $arrayElemAt: ["$refs", `${this.path}.ref`]
                                    },
                                    this.path
                                ]
                            }
                        },
                        in: {
                            $eq: [`$$${variable}.type`, {
                                    $literal: type
                                }]
                        }
                    }
                },
                false
            ];
        }
        else {
            this.expr.$eq = [`${this.path}.type`, { $literal: type }];
        }
        return match;
    }
    /** Clone the arbitrary filter */
    clone() {
        const expr = {};
        const filter = this.deepClone(expr, this.filter);
        return new ArbitraryFilter(this.str, this.path, filter, expr);
    }
    /** Resolve value and ensure the type */
    resolveValue(expr, type) {
        this.expr.$cond = [
            {
                $eq: [`${this.path}.type`, type]
            },
            expr,
            false
        ];
    }
    /** Resolve reference and ensure the type */
    resolveReference(expr, type) {
        const newPath = this.str.str;
        this.str.increment();
        this.expr.$cond = [
            {
                $eq: [`${this.path}.type`, 12 /* Reference */]
            },
            {
                $let: {
                    vars: {
                        [newPath]: {
                            $arrayElemAt: ["$refs", `${this.path}.ref`]
                        }
                    },
                    in: {
                        $cond: [
                            {
                                $eq: [`$$${newPath}.type`, type]
                            },
                            expr,
                            false
                        ]
                    }
                }
            },
            false
        ];
        return `$$${newPath}`;
    }
    /** Deep clone object */
    deepClone(expr, obj) {
        const keys = Object.keys(obj);
        const newObj = {};
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const prop = obj[key];
            if (typeof prop === "object" &&
                prop !== null) {
                if (prop === this.expr)
                    newObj[key] = expr;
                else
                    newObj[key] = this.deepClone(expr, prop);
            }
            else
                newObj[key] = prop;
        }
        return newObj;
    }
}
exports.ArbitraryFilter = ArbitraryFilter;
