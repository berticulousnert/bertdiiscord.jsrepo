import { Match } from "./Match";
import { Length } from "./Length";
import { BoolFilter } from "./Bool";
import { DateFilter } from "./Date";
import { BigFilter } from "./BigInt";
import { NumFilter } from "./Number";
import { StrFilter } from "./String";
import { ArrayFilter } from "./Array";
import { RegexFilter } from "./RegExp";
import { Filter as MongoFilter } from "mongodb";
import { IncrementalString } from "../IncString";
import { Document, DataTypes, Types, Helpers } from "../Types";
/** Filter for querying */
export declare class Filter<T extends Types> {
    /** The key filter */
    get key(): StrFilter<T>;
    /** The data filter */
    get data(): ArbitraryFilter<T, T>;
}
/** Arbitrary filter for data */
export declare class ArbitraryFilter<T extends Types, TData extends Types> {
    protected readonly path: string;
    protected readonly str: IncrementalString;
    protected readonly expr: Record<string, unknown>;
    protected readonly filter: MongoFilter<Document<T>>;
    constructor(str: IncrementalString, path: string, filter: MongoFilter<Document<T>>, expr: Record<string, unknown>);
    /** Filter if the data is nullish */
    get nullish(): Match<T>;
    /** Filter of boolean type */
    bool(): DataTypes.Bool extends Helpers.DataTypeOf<TData> ? BoolFilter<T> : never;
    /** Filter of number type */
    number(): DataTypes.Number extends Helpers.DataTypeOf<TData> ? NumFilter<T> : never;
    /** Filter of bigint type */
    bigint(): DataTypes.BigInt extends Helpers.DataTypeOf<TData> ? BigFilter<T> : never;
    /** Filter of string type */
    string(): DataTypes.String extends Helpers.DataTypeOf<TData> ? StrFilter<T> : never;
    /** Filter of date type */
    date(): DataTypes.Date extends Helpers.DataTypeOf<TData> ? DateFilter<T> : never;
    /** Filter of regexp type */
    regexp(): DataTypes.RegExp extends Helpers.DataTypeOf<TData> ? RegexFilter<T> : never;
    /** Filter of binary data length */
    byteLength(): DataTypes.Bytes extends Helpers.DataTypeOf<TData> ? Length<T> : never;
    /** Filter of array type */
    array(): DataTypes.Array extends Helpers.DataTypeOf<TData> ? TData extends unknown[] ? ArrayFilter<T, TData> : ArrayFilter<T, unknown[]> : never;
    /** Filter of set type */
    set(): DataTypes.Set extends Helpers.DataTypeOf<TData> ? TData extends Set<infer E> ? ArrayFilter<T, E[]> : ArrayFilter<T, unknown[]> : never;
    /** Filter of map value type */
    mapGet(key: string): DataTypes.Map extends Helpers.DataTypeOf<TData> ? TData extends Map<string, infer V> ? ArbitraryFilter<T, V> : ArbitraryFilter<T, unknown> : never;
    /** Filter of object property type */
    objGet<K extends keyof TData>(key: K): DataTypes.Object extends Helpers.DataTypeOf<TData> ? ArbitraryFilter<T, TData[K]> : never;
    /** Filter if data type is equal */
    typeOf(type: DataTypes, resolveRef?: boolean): Match<T>;
    /** Clone the arbitrary filter */
    clone(): ArbitraryFilter<T, TData>;
    /** Resolve value and ensure the type */
    protected resolveValue(expr: Record<string, unknown>, type: DataTypes): void;
    /** Resolve reference and ensure the type */
    protected resolveReference(expr: Record<string, unknown>, type: DataTypes): string;
    /** Deep clone object */
    protected deepClone(expr: Record<string, unknown>, obj: object): object;
}
