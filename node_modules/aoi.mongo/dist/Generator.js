"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateData = exports.generate = exports.GeneratorError = void 0;
const mongodb_1 = require("mongodb");
const Types_1 = require("./Types");
/**
 * The class to represent generator error
 */
class GeneratorError extends Error {
    constructor(message) {
        super(message);
        this.name = "AoiMongoError";
    }
}
exports.GeneratorError = GeneratorError;
/**
 * Generate the key-value pair into document
 * @param key The key as the unique
 * @param value The value to generate
 */
function generate(value, refs) {
    try {
        return generateData(value, refs, new WeakMap());
    }
    catch (err) {
        throw new GeneratorError(err.message);
    }
}
exports.generate = generate;
function generateData(value, refs, refStack) {
    const type = (0, Types_1.getType)(value, refStack);
    switch (type) {
        case 0 /* Null */:
            return {
                type
            };
        case 1 /* Bool */:
            return {
                type,
                bool: value
            };
        case 2 /* Number */:
            return {
                type,
                num: value
            };
        case 3 /* BigInt */:
            return {
                type,
                big: mongodb_1.Long.fromBigInt(value)
            };
        case 4 /* String */:
            return {
                type,
                str: value
            };
        case 5 /* Date */:
            return {
                type,
                date: value
            };
        case 6 /* RegExp */:
            return {
                type,
                regex: value
            };
        case 12 /* Reference */:
            return {
                type,
                ref: refStack.get(value)
            };
        case 7 /* Bytes */:
            {
                const buf = value;
                const index = refs.length;
                refStack.set(buf, index);
                refs.push({
                    type,
                    buf
                });
                return {
                    type: 12 /* Reference */,
                    ref: index
                };
            }
        case 8 /* Array */:
            {
                const arr = value;
                const dataArr = [];
                const index = refs.length;
                refStack.set(arr, index);
                refs.push({
                    type,
                    arr: dataArr
                });
                for (let i = 0; i < arr.length; i++) {
                    const val = arr[i];
                    try {
                        dataArr.push(generateData(val, refs, refStack));
                    }
                    catch (err) {
                        throw forwardError(err, `arr ${i}`);
                    }
                }
                return {
                    type: 12 /* Reference */,
                    ref: index
                };
            }
        case 9 /* Set */:
            {
                const set = value;
                const dataSet = [];
                const index = refs.length;
                refStack.set(set, index);
                refs.push({
                    type,
                    set: dataSet
                });
                let i = 0;
                for (const val of set.values()) {
                    try {
                        dataSet.push(generateData(val, refs, refStack));
                    }
                    catch (err) {
                        throw forwardError(err, `set ${i}`);
                    }
                    i++;
                }
                return {
                    type: 12 /* Reference */,
                    ref: index
                };
            }
        case 10 /* Map */:
            {
                const map = value;
                const dataMap = {};
                const index = refs.length;
                refStack.set(map, index);
                refs.push({
                    type,
                    map: dataMap
                });
                for (const [prop, val] of map) {
                    if (typeof prop === "string" && !prop.startsWith("$") && !prop.includes(".") && !prop.includes("\x00")) {
                        try {
                            dataMap[prop] = generateData(val, refs, refStack);
                        }
                        catch (err) {
                            throw forwardError(err, `map '${prop}'`);
                        }
                    }
                }
                return {
                    type: 12 /* Reference */,
                    ref: index
                };
            }
        case 11 /* Object */:
            {
                const obj = value;
                const dataObj = {};
                const index = refs.length;
                refStack.set(obj, index);
                refs.push({
                    type,
                    obj: dataObj
                });
                const keys = Object.keys(obj);
                for (let i = 0; i < keys.length; i++) {
                    const prop = keys[i];
                    const val = obj[prop];
                    if (!prop.startsWith("$") && !prop.includes(".") && !prop.includes("\x00")) {
                        try {
                            dataObj[prop] = generateData(val, refs, refStack);
                        }
                        catch (err) {
                            throw forwardError(err, `obj '${prop}'`);
                        }
                    }
                }
                return {
                    type: 12 /* Reference */,
                    ref: index
                };
            }
    }
}
exports.generateData = generateData;
function forwardError(err, at) {
    const split = err.message.split("at");
    const msg = split.shift().trim();
    const higherAt = split.length ? split.join("at").trim() : null;
    const message = `${msg} ${higherAt
        ? `at ${at} -> ${higherAt}`
        : `at ${at}`}`;
    return new GeneratorError(message);
}
