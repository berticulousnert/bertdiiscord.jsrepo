import { Long, Document as MongoDocument } from "mongodb";
/** The list of data types in aoi.mongo */
export declare const enum DataTypes {
    Null = 0,
    Bool = 1,
    Number = 2,
    BigInt = 3,
    String = 4,
    Date = 5,
    RegExp = 6,
    Bytes = 7,
    Array = 8,
    Set = 9,
    Map = 10,
    Object = 11,
    Reference = 12
}
/** The document interface */
export interface Doc<T extends Types> {
    key: string;
    value: T;
}
/** The generated document that will be passed to mongodb */
export interface Document<T extends Types> extends MongoDocument {
    key: string;
    data: Data<T>;
    refs: Data<unknown>[];
}
/** The data interface */
export declare type Data<T extends Types> = {
    type: Helpers.DataTypeOf<T>;
} & Helpers.RequiredOf<Helpers.DataTypeOf<T>, T>;
/** The supported types in aoi.mongo */
export declare type Types = undefined | boolean | number | bigint | string | null | Date | RegExp | Uint8Array | unknown[] | Set<unknown> | Map<string, unknown> | {} | unknown;
export declare namespace Helpers {
    type Primitive = undefined | boolean | number | bigint | string;
    type DataTypeOf<T extends Types> = T extends Primitive ? DataTypePrimitive<T> : DataTypeNonPrimitive<T>;
    type DataTypePrimitive<T extends Primitive> = T extends undefined ? DataTypes.Null : T extends boolean ? DataTypes.Bool : T extends number ? DataTypes.Number : T extends bigint ? DataTypes.BigInt : DataTypes.String;
    type DataTypeNonPrimitive<T extends Types> = T extends Date ? DataTypes.Date : T extends RegExp ? DataTypes.RegExp : T extends Uint8Array ? DataTypes.Bytes | DataTypes.Reference : T extends unknown[] ? DataTypes.Array | DataTypes.Reference : T extends Set<unknown> ? DataTypes.Set | DataTypes.Reference : T extends Map<string, unknown> ? DataTypes.Map | DataTypes.Reference : T extends object ? DataTypes.Object | DataTypes.Reference : (DataTypes.Null | DataTypes.Bool | DataTypes.Number | DataTypes.BigInt | DataTypes.String | DataTypes.Date | DataTypes.RegExp | DataTypes.Reference | DataTypes.Bytes | DataTypes.Array | DataTypes.Set | DataTypes.Map | DataTypes.Object);
    type RequiredOf<T extends DataTypes, TData extends Types> = T extends DataTypes.Null ? {} : T extends DataTypes.Bool ? {
        bool: boolean;
    } : T extends DataTypes.Number ? {
        num: number;
    } : T extends DataTypes.BigInt ? {
        big: Long;
    } : T extends DataTypes.String ? {
        str: string;
    } : T extends DataTypes.Date ? {
        date: Date;
    } : T extends DataTypes.RegExp ? {
        regex: RegExp;
    } : T extends DataTypes.Bytes ? {
        buf: Uint8Array;
    } | {
        ref: number;
    } : T extends DataTypes.Array ? {
        arr: (TData extends (infer E)[] ? Data<E>[] : never[]);
    } | {
        ref: number;
    } : T extends DataTypes.Set ? {
        set: (TData extends Set<infer E> ? Data<E>[] : never[]);
    } | {
        ref: number;
    } : T extends DataTypes.Map ? {
        map: (TData extends Map<string, infer V> ? Record<string, Data<V>> : Record<string, never>);
    } | {
        ref: number;
    } : T extends DataTypes.Object ? {
        obj: (TData extends {} ? {
            [K in keyof TData]: TData[K];
        } : Record<string, never>);
    } | {
        ref: number;
    } : {
        bool?: boolean;
        num?: number;
        big?: Long;
        str?: string;
        date?: Date;
        regex?: RegExp;
        buf?: Uint8Array;
        arr?: Data<unknown>[];
        set?: Data<unknown>[];
        map?: Record<string, Data<unknown>>;
        obj?: Record<string, Data<unknown>>;
        ref?: number;
    };
}
/**
 * Utility function to get the type of value
 * @param value The value to get the type from
 * @param refs The map to detect references
 */
export declare function getType<T extends Types>(value: T, refStack: WeakMap<object, number>): Helpers.DataTypeOf<T>;
